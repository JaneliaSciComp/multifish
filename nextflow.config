manifest {
  name = 'JaneliaSciComp/multifish'
  author = 'Janelia MultiFISH Team Project'
  homePage = 'https://github.com/JaneliaSciComp/multifish'
  description = 'Analysis pipeline for EASI-FISH (Expansion-Assisted Iterative Fluorescence In Situ Hybridization)'
  mainScript = 'main.nf'
  nextflowVersion = '>=23.04.1'
  version = '1.1.0'
}

includeConfig 'external-modules/spark/nextflow.config'

params {
    lsf_opts = ''
    lsf_queue_size = 500
    runtime_opts = ''
    singularity_cache_dir = getEnvValue("HOME", "/tmp") + "/.singularity_cache"
    singularity_user = getEnvValue("USER", null)
    user_id = getUID()

    data_dir = ''
    output_dir = ''
    publish_dir = ''
    shared_work_dir = ''
    mounted_volumes = ''

    // default parameter for all acquisitions that must be processed
    // should only be used when all steps must be performed for all acquisions
    acq_names = ''
    ref_acq = '' // data from specified acquisiotn will be used as reference for registration and/or segmentation

    darkfield_file = ''
    flatfield_file = ''

    dapi_channel = 'c2' // DAPI channel used to drive both the segmentation and the registration
    bleed_channel = 'c3'

    use_bigstream = false
    use_cellpose = false
}

if (params.use_bigstream) {
    includeConfig './bigstream-nextflow.config'
}

if (params.use_cellpose) {
    includeConfig './cellpose-nextflow.config'
}

process {
    beforeScript = 'export PROCESS_DIR=`pwd`' 

    withLabel: small {
        cpus = 1
        memory = '1.GB'
    }
}

profiles {

    standard {
        docker.enabled = false
        singularity.enabled = true
        process {
            withLabel: withGPU {
                containerOptions = "--nv"
            }
        }
    }

    localsingularity {
        docker.enabled = false
        singularity.enabled = true
        process {
            withLabel: withGPU {
                containerOptions = "--nv"
            }
        }
    }
    
    localdocker {
        docker.enabled = true
        singularity.enabled = false
        apptainer.enabled = false
    }

    lsf {
        executor {
            queueSize = params.lsf_queue_size
        }

        process {
            executor = 'lsf'
            clusterOptions = params.lsf_opts

            withLabel: withGPU {
                queue = 'gpu_rtx'
                clusterOptions = '-gpu "num=1" ' + params.lsf_opts
                containerOptions = "--nv"
            }

            withLabel: withAVX2 {
                clusterOptions = '-R"select[avx2]" ' + params.lsf_opts
            }

            withLabel: preferLocal {
                executor = 'local'
            }
        }
        docker.enabled = false
        singularity.enabled = true
        apptainer.enabled = false
    }

    kubernetes {
        process {
            executor = 'k8s'
        }

        k8s {
            autoMountHostPaths = true
            debug.yaml = true
            computeResourceType = 'Job'
            httpConnectTimeout = '600s'
            httpReadTimeout = '600s'
            securityContext = [
                runAsUser: params.user_id
            ]
            pullPolicy = 'Always'
            context = 'nfcontext'
            namespace = 'default'
            pod = [
                [env: 'ITK_THREADS', value: params.bigstream_worker_cpus as String],
                [ automountServiceAccountToken:false ],
            ] +
            get_mounted_volumes(params.mounted_volumes)
        }
    }

    tower {
        process {
            withLabel: withGPU {
                containerOptions = params.runtime_opts
            }
        }
        docker.enabled = true
        singularity.enabled = false
        apptainer.enabled = false
        params.singularity_user = "ec2_user"
    }

    tower_gpu {
        process {
            withLabel: withGPU {
                accelerator = 1
                containerOptions = "--runtime nvidia ${params.runtime_opts}"
            }
        }
        docker.enabled = true
        singularity.enabled = false
        apptainer.enabled = false
    }

    awsbatch {
        aws {
            region = 'us-east-1'

            client {
                maxConnections = 20
                connectionTimeout = 10000
            }

            batch {
                cliPath = '/home/ec2-user/miniconda/bin/aws'
                maxTransferAttempts = 10
                volumes = [ '/tmp', '/s3-multifish', '/efs-multifish' ]
                jobRole = 'easi-multifish-dev-ECSTaskRole'
            }
        }

        process {
            executor = 'awsbatch'
            queue = 'easi-multifish-dev-multifish-cpu-job-queue'

            withLabel: small {
                queue = 'easi-multifish-dev-multifish-small-cpu-job-queue'
            }

            withLabel: withGPU {
                accelerator = 1
                queue = 'easi-multifish-dev-multifish-gpu-job-queue'
                containerOptions = "--runtime nvidia ${params.runtime_opts}"
            }
        }
        docker.enabled = true
        singularity.enabled = false
        apptainer.enabled = false
    }

}

singularity {
    autoMounts = true
    cacheDir = params.singularity_cache_dir
    runOptions = "-e --env PROCESS_DIR=\$PROCESS_DIR --env USER=${params.singularity_user} ${params.runtime_opts}"
}

apptainer {
    autoMounts = true
    cacheDir = "${params.singularity_cache_dir}"
    runOptions = "-e --env PROCESS_DIR=\$PROCESS_DIR --env USER=${params.singularity_user} ${params.runtime_opts}"
}

// Borrowed from nf-virontus/nextflow.config
// Try to get a system environment variable value with some key. If the key
// doesn't exist, then return a default value
def getEnvValue(envKey, defaultValue = null) {
  envMap = new HashMap(System.getenv())
  if (envMap.containsKey(envKey)) {
    envMap[envKey]
  } else {
    defaultValue
  }
}

def getUID() {
    def p = Runtime.getRuntime().exec('id -u')
    try (InputStreamReader pout = new InputStreamReader(p.inputStream)) {
        pout.readLine() as Integer
    }
}

def arg_value(arg_flag, arg_value) {
    "${arg_flag} ${arg_value}"
}

def bool_arg(arg_flag, arg_value) {
    arg_value ? "${arg_flag}" : ''
}

def optional_arg_value(arg_flag, arg_value) {
    arg_value ? "${arg_flag} ${arg_value}" : ''
}

def get_mounted_volumes(bindings) {
    bindings.split(',')
        .collect {
            def binding = it.split(':')
            def hostPath = binding[0].trim()
            def mountPath = binding.size() > 1 && binding[1].trim() ? binding[1].trim() : hostPath
	    [
	       hostPath : hostPath as String,
	       mountPath: mountPath as String,
	    ]
        }
}
